<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Building a Blockchain from scratch</h1><p class="post-meta post-meta-title"><time class="dt-published" datetime="2022-01-16T00:00:00-06:00" itemprop="datePublished">
        Jan 16, 2022
      </time>
       â€¢ <span class="read-time" title="Estimated read time">
    
    
      8 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#computer science">computer science</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#blockchain">blockchain</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          
          
          
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2022-01-16-blockchains.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>What will be covered</p>
<ul>
<li>My goals</li>
<li>What is a blockchain</li>
<li>Building a blockchain from scratch</li>
<li>My implementation</li>
<li>Future development</li>
<li>Appendix A</li>
</ul>
<h2 id="Goals">Goals<a class="anchor-link" href="#Goals"> </a></h2><p>My goal with this post and the code I have and will be writing is to get a solid understanding of how blockchains and crypto currencies work from the ground up. There is no better way to learn something that by doing it yourself.
Firstly, I will implement a blockchain (this post), thereafter I will use the blockchain to build a distributed ledger and finally I shall build a crypto currency.</p>
<h2 id="What-is-a-blockchain">What is a blockchain<a class="anchor-link" href="#What-is-a-blockchain"> </a></h2><p>A blockchain is essentially just a linked list with extra features. These features make it hard to tamper with the data and easy to check the validity of the data. People use blockchains for many things. Most popularly for crypto currencies. Since it is anonymous individuals that manage the creation and validation of transactions. One wouldn't want someone to go back and change their account balance in order to make them rich. The currency is safe for as long as most individuals are honest.</p>
<h2 id="Implementing-a-Blockchain">Implementing a Blockchain<a class="anchor-link" href="#Implementing-a-Blockchain"> </a></h2><p>We will now implement a blockchain from scratch. To illustrate this, we will first implement a simple linked list and then build upon it until it becomes a blockchain.</p>
<h3 id="Linked-List">Linked List<a class="anchor-link" href="#Linked-List"> </a></h3><p>As the name suggests a linked list is a list where the data is linked together. An array on the other hand is data in memory stored in adjacent memory addresses.
Note that the usual term for the object that stores the data in a linked list is <code>node</code>, however in blockchains the term is <code>block</code>.</p>
<p>Normally one would implement a singly linked list like this:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="n">next_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">data</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="n">head</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="k">while</span> <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span><span class="p">:</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span>
            <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The first node gets an empty string as prevous hash because there are not previous nodes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The problem with a simple linked list is that you can change the data anywhere in the list. Like so:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">linked_list</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">linked_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># Change the value of the third node</span>
<span class="n">linked_list</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next_node</span><span class="o">.</span><span class="n">next_node</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">12897</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Adding-the-hash-of-the-previous-block">Adding the hash of the previous block<a class="anchor-link" href="#Adding-the-hash-of-the-previous-block"> </a></h3><p>We do not want anyone to change the data, so we add the hash of the previous node to the next node's fields. Now to check if the data in a node has been tampered with, we just recompute the hash of the previous node and compare with the current nodes "hash of the previous block".</p>
<p>A quick refresher about hashes. A hash is the output of a hash function. Sometimes referred to as a fingerprint of some piece of data. A hash function is a so called "one way" function. You can easily compute the hash of a piece of data, but it is very hard to go from the hash to the original piece of data. The only way is to use "brute-force" and try all different combinations of inputs.  If the original piece of data is longer than the hash, it is impossible since information has been lost. As shown in the example below, just a small change in the input creates a completely different output. Despite this, the function is non probabilistic, which means that a input will <strong>always</strong> have the same output.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha256</span>
<span class="k">def</span> <span class="nf">hasher</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sha256</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hasher</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hasher</span><span class="p">(</span><span class="s2">&quot;Hello World!&quot;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>a591a6d40bf420404a011733cfb7b190d62c65bf0bcda32b57b277d9ad9f146e
7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To add the hash of the previous block we add the field <code>previous_node_hash</code> to the node.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="n">next_node</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">previous_node_hash</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span><span class="nb">str</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">previous_node_hash</span> <span class="o">=</span> <span class="n">previous_node_hash</span>
        
<span class="k">class</span> <span class="nc">LinkedList</span><span class="p">:</span>
    <span class="n">head</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span>
            <span class="k">while</span> <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span><span class="p">:</span>
                <span class="n">current_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span>
                
            <span class="n">current_node_hash</span> <span class="o">=</span> <span class="n">sha256</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">current_node</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span> <span class="c1"># &lt;-----</span>
            <span class="n">current_node</span><span class="o">.</span><span class="n">next_node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">current_node_hash</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> 
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A node now looks like this when printed</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">linked_list</span> <span class="o">=</span> <span class="n">LinkedList</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">linked_list</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">linked_list</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">next_node</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{&#39;data&#39;: &#39;1&#39;, &#39;previous_node_hash&#39;: &#39;0e69ce586d540294b97a90e1f224ffd1af1d672007cea72221fc18955550051e&#39;, &#39;next_node&#39;: &lt;__main__.Node object at 0x108c045e0&gt;}
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We now have officially created the most basic blockchain! Now, you can still change the value of <code>Node.data</code>. But that would make the next node's <code>Node.prevous_node_hash</code> incorrect. So, you would have to recompute the hash of the edited node and update the next node. However, now the hash in the following node does not match the one after that. You would have to change all the hashes until you arrive at the last node. In the case of crypto currencies, imagine that it takes monstrous amount of computation to add just a single node to the list and you start to realize why it is infeasible to edit the record. While you are changing the record and recomputing the whole chain, hundreds of thousands of computers are trying to add new nodes to the end of chain. You would never catch up.</p>
<p>Bitcoin and PyChain split the information in the node (from now on referred to as block) into two sections: a header and a body. This is done in order to save space and computation. For a lot of operations, you do not need the body; you just need a hash of it in order to validate the data should you want to.</p>
<p>Since PyChain is a general purpose blockchain, it can also discard some header fields that are present in bitcoin's header. For example: version, difficulty target and nonce. All of these are application specific and are important for bitcoin, but not to PyChain. Perhaps a field could be added to PyChain's header that could be used to store some information.</p>
<h3 id="Implementing-PyChain">Implementing PyChain<a class="anchor-link" href="#Implementing-PyChain"> </a></h3><p>PyChain is extremely simple, let's implement part of it:</p>
<h4 id="Block">Block<a class="anchor-link" href="#Block"> </a></h4><p>A block is defined as follows:</p>

<pre><code>======HEADER==========
4 bytes    (I): block number       : 0:4
32 bytes (32s): previous block hash: 4:36
32 bytes (32s): block body hash    : 36:68
8 bytes    (Q): block creation time: 68:76
======END HEADER======
======BODY============
n bytes   (ns): block body         : 76:n
======END BODY========</code></pre>
<p>The index of the block in the chain, the previous block's hash, the hash of the body, the time when the block was created and the body. The header is of fixed size, always 76 bytes. However, the body has a variable size, but is easy to compute: <code>len(block)-76</code>.</p>
<p>PyChain uses <a href="https://docs.python.org/3/library/struct.html">struct</a> in order to encode and decode blocks.</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span> <span class="c1"># a library to create C-style structs</span>

<span class="k">def</span> <span class="nf">encode_block</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">prev_hash</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Encode a block</span>
<span class="sd">    Packs the block into an array of bytes</span>
<span class="sd">    :param n: block number</span>
<span class="sd">    :param prev_hash: previous block hash</span>
<span class="sd">    :param time: time of block creation</span>
<span class="sd">    :param body: block body</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">block</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=I32s32sQ</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">prev_hash</span><span class="p">,</span> <span class="n">sha256</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span> <span class="n">time</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">block</span>

<span class="k">def</span> <span class="nf">decode_block</span><span class="p">(</span><span class="n">block</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Decode a block</span>
<span class="sd">    Unpacks the block into an array of bytes</span>
<span class="sd">    Note: the 76 in the format string is the length of the header</span>
<span class="sd">    :param block: block to decode</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">prev_hash</span><span class="p">,</span> <span class="n">body_hash</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;=I32s32sQ</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="p">)</span><span class="o">-</span><span class="mi">76</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">prev_hash</span><span class="p">,</span> <span class="n">body_hash</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">body</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</pre></div>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>These functions basically just take several values and either packs or unpacks them in order to achieve a C-like space efficiency. Easy as that. If you are unfamiliar with this library this is how it works:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">struct</span>
<span class="nb">print</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;2I&quot;</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">456</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>b&#39;{\x00\x00\x00\xc8\x01\x00\x00&#39;
</pre>
</div>
</div>

</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;2I&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s1">&#39;{</span><span class="se">\x00\x00\x00\xc8\x01\x00\x00</span><span class="s1">&#39;</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(123, 456)
</pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The format of a block is <code>I32s32sQ{len(body)}s</code>. Where <code>I</code>s are integers, <code>s</code>s are char arrays and <code>Q</code>s are unsigned longs. The number before the letter specifies how many of that type there are. Since the body has a variable number of <code>s</code>, it can be calculated using <code>{len(block)-76}s</code>.</p>
<p>To add a block to the chain we simply:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BlockChain</span><span class="p">:</span>
    <span class="n">blocks</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">HEADER_SLICE</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">76</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No genesis block&quot;</span><span class="p">)</span>
        <span class="n">prev_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">HEADER_SLICE</span><span class="p">]</span> <span class="c1"># Get the header of the previous block</span>
        <span class="n">prev_hash</span> <span class="o">=</span> <span class="n">sha256</span><span class="p">(</span><span class="n">prev_header</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
        <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_block</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">),</span> <span class="n">prev_hash</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">()),</span> <span class="n">body</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
</pre></div>
<h3 id="Performance-of-PyChain">Performance of PyChain<a class="anchor-link" href="#Performance-of-PyChain"> </a></h3><h4 id="Speed">Speed<a class="anchor-link" href="#Speed"> </a></h4><p>Since adding a block to the chain simply requires you to compute one hash and pack the data it is extremely fast. It takes only 24ms to add 10K blocks to the chain. That is 2.352 microseconds per block. The reason distributed blockchains take so long (approx. 10min for bitcoin) is because consensus is needed. In bitcoins case, to add one block hundreds of thousands of computers need to find a value that results in the header's hash starting with n number of zeros. The number of calculations needed to do this are astronomical.</p>
<h4 id="Space">Space<a class="anchor-link" href="#Space"> </a></h4><p>A blockchain containing 10K blocks (with empty bodies) would be <code>10000 blocks x 76 bytes = 760 KB</code>. This is slightly better than bitcoin which has a header of 80 bytes.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Future-development">Future development<a class="anchor-link" href="#Future-development"> </a></h2><p>PyChain needs some unit tests and more chain validation features in order to move to the next step.</p>
<p>The following step is to create a peer-to-peer protocol that would enable this blockchain implementation to be distributed. Of the top of my head, that would require the following abilities:</p>
<ul>
<li>broadcast new block</li>
<li>get blocks (ask for blocks from peers)</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Appendix-A">Appendix A<a class="anchor-link" href="#Appendix-A"> </a></h3><p>Fun fact! The <a href="https://github.com/nicoloridulfo/PyChain/tree/713a4a5a4e8055d1a127ff3d0c26f0b3efa737c7">current version of PyChain</a> can be minified and fit in 31 <strong>unreadable</strong> lines of code:</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">O</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">round</span><span class="p">,</span> <span class="nb">staticmethod</span><span class="p">,</span> <span class="nb">isinstance</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">print</span><span class="p">,</span> <span class="nb">slice</span><span class="p">,</span> <span class="nb">len</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">sha256</span> <span class="k">as</span> <span class="n">E</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span> <span class="k">as</span> <span class="n">G</span>
<span class="kn">import</span> <span class="nn">struct</span> <span class="k">as</span> <span class="nn">D</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="k">class</span> <span class="nc">K</span><span class="p">:</span>
    <span class="n">blocks</span><span class="o">=</span><span class="p">[];</span><span class="n">HEADER_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span><span class="n">BLOCK_NR_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span><span class="n">PREV_HASH_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">40</span><span class="p">);</span><span class="n">BODY_HASH_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span><span class="mi">72</span><span class="p">);</span><span class="n">BLOCK_CREATION_TIME_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">72</span><span class="p">,</span><span class="mi">80</span><span class="p">);</span><span class="n">BODY_SLICE</span><span class="o">=</span><span class="n">B</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">add_block</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">body</span><span class="p">):</span><span class="n">B</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">HEADER_SLICE</span><span class="p">];</span><span class="n">D</span><span class="o">=</span><span class="n">E</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">digest</span><span class="p">();</span><span class="n">F</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">encode_block</span><span class="p">(</span><span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">),</span><span class="n">D</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">G</span><span class="p">()),</span><span class="n">body</span><span class="p">);</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">verify_chain</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
        <span class="n">P</span><span class="o">=</span><span class="s1">&#39;=Q&#39;</span><span class="p">;</span><span class="n">O</span><span class="o">=</span><span class="kc">True</span><span class="p">;</span><span class="n">F</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">if</span> <span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span><span class="k">return</span> <span class="n">O</span>
        <span class="k">for</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">L</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">)):</span>
            <span class="n">G</span><span class="o">=</span><span class="n">E</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">HEADER_SLICE</span><span class="p">])</span><span class="o">.</span><span class="n">digest</span><span class="p">();</span><span class="n">H</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">PREV_HASH_SLICE</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">!=</span><span class="n">H</span><span class="p">:</span><span class="k">return</span> <span class="n">F</span>
            <span class="n">I</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">BODY_HASH_SLICE</span><span class="p">];</span><span class="n">J</span><span class="o">=</span><span class="n">E</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">BODY_SLICE</span><span class="p">])</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">I</span><span class="o">!=</span><span class="n">J</span><span class="p">:</span><span class="k">return</span> <span class="n">F</span>
            <span class="n">K</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;=I&#39;</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">BLOCK_NR_SLICE</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">K</span><span class="o">!=</span><span class="n">B</span><span class="p">:</span><span class="k">return</span> <span class="n">F</span>
            <span class="n">M</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">BLOCK_CREATION_TIME_SLICE</span><span class="p">])[</span><span class="mi">0</span><span class="p">];</span><span class="n">N</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">B</span><span class="p">][</span><span class="n">A</span><span class="o">.</span><span class="n">BLOCK_CREATION_TIME_SLICE</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">N</span><span class="o">&lt;</span><span class="n">M</span><span class="p">:</span><span class="k">return</span> <span class="n">F</span>
        <span class="k">return</span> <span class="n">O</span>
    <span class="k">def</span> <span class="nf">import_chain</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="n">chain</span><span class="p">):</span>
        <span class="n">A</span><span class="o">=</span><span class="n">chain</span>
        <span class="k">if</span> <span class="n">M</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span><span class="n">B</span><span class="o">.</span><span class="n">blocks</span><span class="o">=</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">M</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="nb">bytes</span><span class="p">):</span><span class="n">B</span><span class="o">.</span><span class="n">blocks</span><span class="o">=</span><span class="p">[</span><span class="n">A</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span><span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Invalid import data&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">export_chain</span><span class="p">(</span><span class="n">A</span><span class="p">):</span><span class="k">return</span> <span class="n">A</span><span class="o">.</span><span class="n">blocks</span>
    <span class="nd">@N</span>
    <span class="k">def</span> <span class="nf">encode_block</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">prev_hash</span><span class="p">,</span><span class="n">time</span><span class="p">,</span><span class="n">body</span><span class="p">):</span><span class="n">A</span><span class="o">=</span><span class="n">body</span><span class="p">;</span><span class="n">B</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=2I32s32sQ</span><span class="si">{</span><span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span><span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="p">),</span><span class="n">n</span><span class="p">,</span><span class="n">prev_hash</span><span class="p">,</span><span class="n">E</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">digest</span><span class="p">(),</span><span class="n">time</span><span class="p">,</span><span class="n">A</span><span class="o">.</span><span class="n">encode</span><span class="p">());</span><span class="k">return</span> <span class="n">B</span>
    <span class="nd">@N</span>
    <span class="k">def</span> <span class="nf">decode_block</span><span class="p">(</span><span class="n">block</span><span class="p">):</span><span class="n">A</span><span class="o">=</span><span class="n">block</span><span class="p">;</span><span class="n">B</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">I</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=2I32s32sQ</span><span class="si">{</span><span class="n">C</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">-</span><span class="mi">80</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">,</span><span class="n">A</span><span class="p">);</span><span class="k">return</span> <span class="n">B</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="n">F</span><span class="p">,</span><span class="n">G</span><span class="p">,</span><span class="n">H</span><span class="p">,</span><span class="n">I</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

</div>



  </div><a class="u-url" href="/computer%20science/blockchain/2022/01/16/blockchains.html" hidden></a>
</article>